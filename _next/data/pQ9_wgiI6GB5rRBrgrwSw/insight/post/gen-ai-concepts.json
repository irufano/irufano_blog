{"pageProps":{"post":{"slug":"gen-ai-concepts","meta":{"title":"Generative AI Key Concepts","date":"2024-09-24","description":"Machine learning is a subset of AI that involves developing algorithms that allow computers to learn from & make predictions or decisions based on data.","author":"irufano","tags":["AI","Generative AI"],"image":"https://raw.githubusercontent.com/microsoft/generative-ai-for-beginners/main/01-introduction-to-genai/images/AI-diagram.png"},"content":"<h2 id=\"definition\">Definition</h2>\n<p>Generative AI refers to a type of artificial intelligence that creates new content, such as images, text, audio, or even video, based on patterns and data it has learned. What makes it a fantastic technology is that it democratizes AI, anyone can use it with as little as a text prompt, a sentence written in a natural language. There's no need for you to learn a language like Java or SQL to accomplish something worthwhile, all you need is to use your language, state what you want and out comes a suggestion from an AI model. The applications and impact for this is huge, you write or understand reports, write applications and much more, all in seconds.</p>\n<p>After decades of research in the AI field, a new model architecture – called Transformer – overcame the limits of RNNs, being able to get much longer sequences of text as input. Transformers are based on the attention mechanism, enabling the model to give different weights to the inputs it receives, ‘paying more attention’ where the most relevant information is concentrated, regardless of their order in the text sequence.</p>\n<p>Most of the recent generative AI models – also known as Large Language Models (LLMs), since they work with textual inputs and outputs – are indeed based on this architecture. What’s interesting about these models – trained on a huge amount of unlabeled data from diverse sources like books, articles and websites – is that they can be adapted to a wide variety of tasks and generate grammatically correct text with a semblance of creativity. So, not only did they incredibly enhance the capacity of a machine to ‘understand’ an input text, but they enabled their capacity to generate an original response in human language.</p>\n<h2 id=\"how-do-large-language-models-work\">How do large language models work?</h2>\n<h3 id=\"tokenization\">Tokenization</h3>\n<p>Large Language Models receive a text as input and generate a text as output. However, being statistical models, they work much better with numbers than text sequences. That’s why every input to the model is processed by a tokenizer, before being used by the core model. A token is a chunk of text – consisting of a variable number of characters, so the tokenizer's main task is splitting the input into an array of tokens. Then, each token is mapped with a token index, which is the integer encoding of the original text chunk.</p>\n<p><img src=\"https://github.com/irufano/generative-ai-for-beginners/raw/main/01-introduction-to-genai/images/tokenizer-example.png?WT.mc_id=academic-105485-koreyst\" alt=\"image\"></p>\n<h3 id=\"predicting-output-tokens\">Predicting output tokens</h3>\n<p>Given n tokens as input (with max n varying from one model to another), the model is able to predict one token as output. This token is then incorporated into the input of the next iteration, in an expanding window pattern, enabling a better user experience of getting one (or multiple) sentence as an answer. This explains why, if you ever played with ChatGPT, you might have noticed that sometimes it looks like it stops in the middle of a sentence.</p>\n<h3 id=\"selection-process\">Selection process</h3>\n<p>The output token is chosen by the model according to its probability of occurring after the current text sequence. This is because the model predicts a probability distribution over all possible ‘next tokens’, calculated based on its training. However, not always the token with the highest probability is chosen from the resulting distribution. A degree of randomness is added to this choice, in a way that the model acts in a non-deterministic fashion - we do not get the exact same output for the same input. This degree of randomness is added to simulate the process of creative thinking and it can be tuned using a model parameter called temperature.</p>\n<h2 id=\"custom-knowledge-base\">Custom Knowledge Base</h2>\n<p>To add a knowledge base to an OpenAI-powered chatbot or application, you can use a variety of approaches depending on how dynamic and structured you want your knowledge base to be. Here are some common methods:</p>\n<h3 id=\"embedding-knowledge-with-fine-tuning\">Embedding Knowledge with Fine-Tuning</h3>\n<ul>\n<li><span class=\"strong-block\">Fine-tuning</span>: You can fine-tune the OpenAI model on your specific knowledge base or domain. This involves training the model on a custom dataset (such as product information, FAQs, internal documents) to improve its responses.\n<ul>\n<li>Steps:\n<ul>\n<li>Collect data (e.g., text documents, structured data).</li>\n<li>Format it into the proper input-output pairs (prompts and completions).</li>\n<li>Fine-tune the model using OpenAI's fine-tuning API.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><span class=\"strong-block\">Use case</span>: Best for cases where knowledge is mostly static and doesn’t change often.</li>\n</ul>\n<h3 id=\"use-knowledge-base-api-and-dynamic-retrieval\">Use Knowledge Base API and Dynamic Retrieval</h3>\n<ul>\n<li><span class=\"strong-block\">External APIs</span>: Integrate the chatbot with a real-time knowledge base, such as a MySQL database, content management system, or external API.\n<ul>\n<li><span class=\"strong-block\">Method</span>: Implement a retrieval mechanism that allows the chatbot to fetch answers from your dynamic database based on user queries. For instance, using vector embeddings to match user queries with the most relevant content in the database.</li>\n<li><span class=\"strong-block\">Tools</span>: You can use libraries like langchain to facilitate this process, creating a pipeline that pulls data dynamically based on user input.</li>\n</ul>\n</li>\n<li><span class=\"strong-block\">Use case</span>: Useful when your knowledge base is large, changes frequently, or needs to handle complex queries.</li>\n</ul>\n<h3 id=\"contextual-knowledge-with-prompts\">Contextual Knowledge with Prompts</h3>\n<ul>\n<li><span class=\"strong-block\">Long prompts with context</span>: You can inject specific information about your knowledge base directly into the prompt as context.\n<ul>\n<li><span class=\"strong-block\">Method</span>: Before each query, construct a detailed prompt that includes relevant information from your knowledge base, which the model will use to provide context-aware answers.</li>\n<li><span class=\"strong-block\">Use case</span>: Best for handling small sets of information or specific queries where the information needed is known beforehand.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"augmenting-with-vector-databases-eg-pinecone-faiss\">Augmenting with Vector Databases (e.g., Pinecone, FAISS)</h3>\n<ul>\n<li><span class=\"strong-block\">Vector search</span>: Store your knowledge base as embeddings in a vector database (like Pinecone, Weaviate, or FAISS). When a user asks a question, convert it to a vector, search for the most relevant knowledge entry, and use the result as part of the answer.\n<ul>\n<li><span class=\"strong-block\">Method</span>: Convert text to embeddings using OpenAI or other models, and retrieve the most similar data points in response to a user query.</li>\n<li><span class=\"strong-block\">Use case:</span> Perfect for large datasets where similarity search is required to find relevant answers.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"hybrid-approach-with-langchain-and-fastapi\">Hybrid Approach with LangChain and FastAPI</h3>\n<ul>\n<li>LangChain: LangChain enables building large language model (LLM) applications that can dynamically interact with databases and external systems. It helps set up a chatbot that can fetch data from knowledge bases like databases, APIs, and even web pages.\n<ul>\n<li>Steps:\n<ol>\n<li>Store Knowledge: Define a knowledge base, which could be a SQL database, document store, or API.</li>\n<li>Query Execution: Use an LLM with the LangChain framework to query the knowledge base dynamically.</li>\n<li>FastAPI Integration: Combine this with FastAPI for serving the chatbot with dynamic knowledge retrieval.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"document-retrieval-with-plugins-or-middleware\">Document Retrieval with Plugins or Middleware</h3>\n<ul>\n<li>OpenAI Plugins: If you're using OpenAI in an application, consider building or using a plugin or middleware that acts as a bridge to your knowledge base. For example, retrieving documents, querying databases, or even triggering workflows (e.g., customer support tickets) based on the query.</li>\n<li>Use case: Ideal for more complex enterprise solutions, where OpenAI can function alongside existing systems.</li>\n</ul>\n<h3 id=\"hybrid-qa-pipelines-llm--traditional-search\">Hybrid QA Pipelines (LLM + Traditional Search)</h3>\n<ul>\n<li><span class=\"strong-block\">Combining LLMs with traditional search</span>: You can combine the capabilities of language models with traditional search mechanisms like Elasticsearch or other keyword-based systems.\n<ul>\n<li><span class=\"strong-block\">Method</span>: First, use search engines to retrieve relevant documents, and then pass those documents to OpenAI for processing and summarization.</li>\n<li><span class=\"strong-block\">Use case</span>: Works well in applications where quick retrieval from a large corpus of documents is needed, and then those documents are summarized or clarified by the LLM.</li>\n</ul>\n</li>\n</ul>\n","sections":[{"level":"2","id":"definition","text":"Definition"},{"level":"2","id":"how-do-large-language-models-work","text":"How do large language models work?"},{"level":"3","id":"tokenization","text":"Tokenization"},{"level":"3","id":"predicting-output-tokens","text":"Predicting output tokens"},{"level":"3","id":"selection-process","text":"Selection process"},{"level":"2","id":"custom-knowledge-base","text":"Custom Knowledge Base"},{"level":"3","id":"embedding-knowledge-with-fine-tuning","text":"Embedding Knowledge with Fine-Tuning"},{"level":"3","id":"use-knowledge-base-api-and-dynamic-retrieval","text":"Use Knowledge Base API and Dynamic Retrieval"},{"level":"3","id":"contextual-knowledge-with-prompts","text":"Contextual Knowledge with Prompts"},{"level":"3","id":"augmenting-with-vector-databases-eg-pinecone-faiss","text":"Augmenting with Vector Databases (e.g., Pinecone, FAISS)"},{"level":"3","id":"hybrid-approach-with-langchain-and-fastapi","text":"Hybrid Approach with LangChain and FastAPI"},{"level":"3","id":"document-retrieval-with-plugins-or-middleware","text":"Document Retrieval with Plugins or Middleware"},{"level":"3","id":"hybrid-qa-pipelines-llm--traditional-search","text":"Hybrid QA Pipelines (LLM + Traditional Search)"}],"raw":"\n## Definition\n\nGenerative AI refers to a type of artificial intelligence that creates new content, such as images, text, audio, or even video, based on patterns and data it has learned. What makes it a fantastic technology is that it democratizes AI, anyone can use it with as little as a text prompt, a sentence written in a natural language. There's no need for you to learn a language like Java or SQL to accomplish something worthwhile, all you need is to use your language, state what you want and out comes a suggestion from an AI model. The applications and impact for this is huge, you write or understand reports, write applications and much more, all in seconds.\n\nAfter decades of research in the AI field, a new model architecture – called Transformer – overcame the limits of RNNs, being able to get much longer sequences of text as input. Transformers are based on the attention mechanism, enabling the model to give different weights to the inputs it receives, ‘paying more attention’ where the most relevant information is concentrated, regardless of their order in the text sequence.\n\nMost of the recent generative AI models – also known as Large Language Models (LLMs), since they work with textual inputs and outputs – are indeed based on this architecture. What’s interesting about these models – trained on a huge amount of unlabeled data from diverse sources like books, articles and websites – is that they can be adapted to a wide variety of tasks and generate grammatically correct text with a semblance of creativity. So, not only did they incredibly enhance the capacity of a machine to ‘understand’ an input text, but they enabled their capacity to generate an original response in human language.\n\n## How do large language models work?\n\n### Tokenization\n\nLarge Language Models receive a text as input and generate a text as output. However, being statistical models, they work much better with numbers than text sequences. That’s why every input to the model is processed by a tokenizer, before being used by the core model. A token is a chunk of text – consisting of a variable number of characters, so the tokenizer's main task is splitting the input into an array of tokens. Then, each token is mapped with a token index, which is the integer encoding of the original text chunk.\n\n![image](https://github.com/irufano/generative-ai-for-beginners/raw/main/01-introduction-to-genai/images/tokenizer-example.png?WT.mc_id=academic-105485-koreyst)\n\n### Predicting output tokens\n\nGiven n tokens as input (with max n varying from one model to another), the model is able to predict one token as output. This token is then incorporated into the input of the next iteration, in an expanding window pattern, enabling a better user experience of getting one (or multiple) sentence as an answer. This explains why, if you ever played with ChatGPT, you might have noticed that sometimes it looks like it stops in the middle of a sentence.\n\n### Selection process\n\nThe output token is chosen by the model according to its probability of occurring after the current text sequence. This is because the model predicts a probability distribution over all possible ‘next tokens’, calculated based on its training. However, not always the token with the highest probability is chosen from the resulting distribution. A degree of randomness is added to this choice, in a way that the model acts in a non-deterministic fashion - we do not get the exact same output for the same input. This degree of randomness is added to simulate the process of creative thinking and it can be tuned using a model parameter called temperature.\n\n## Custom Knowledge Base\n\nTo add a knowledge base to an OpenAI-powered chatbot or application, you can use a variety of approaches depending on how dynamic and structured you want your knowledge base to be. Here are some common methods:\n\n###  Embedding Knowledge with Fine-Tuning\n- **Fine-tuning**: You can fine-tune the OpenAI model on your specific knowledge base or domain. This involves training the model on a custom dataset (such as product information, FAQs, internal documents) to improve its responses.\n  - Steps:\n    - Collect data (e.g., text documents, structured data).\n    - Format it into the proper input-output pairs (prompts and completions).\n    - Fine-tune the model using OpenAI's fine-tuning API.\n- **Use case**: Best for cases where knowledge is mostly static and doesn’t change often.\n\n### Use Knowledge Base API and Dynamic Retrieval\n\n- **External APIs**: Integrate the chatbot with a real-time knowledge base, such as a MySQL database, content management system, or external API.\n  - **Method**: Implement a retrieval mechanism that allows the chatbot to fetch answers from your dynamic database based on user queries. For instance, using vector embeddings to match user queries with the most relevant content in the database.\n  - **Tools**: You can use libraries like langchain to facilitate this process, creating a pipeline that pulls data dynamically based on user input.\n- **Use case**: Useful when your knowledge base is large, changes frequently, or needs to handle complex queries.\n\n### Contextual Knowledge with Prompts\n\n- **Long prompts with context**: You can inject specific information about your knowledge base directly into the prompt as context.\n  - **Method**: Before each query, construct a detailed prompt that includes relevant information from your knowledge base, which the model will use to provide context-aware answers.\n  - **Use case**: Best for handling small sets of information or specific queries where the information needed is known beforehand.\n\n### Augmenting with Vector Databases (e.g., Pinecone, FAISS)\n\n- **Vector search**: Store your knowledge base as embeddings in a vector database (like Pinecone, Weaviate, or FAISS). When a user asks a question, convert it to a vector, search for the most relevant knowledge entry, and use the result as part of the answer.\n  - **Method**: Convert text to embeddings using OpenAI or other models, and retrieve the most similar data points in response to a user query.\n  - **Use case:** Perfect for large datasets where similarity search is required to find relevant answers.\n\n### Hybrid Approach with LangChain and FastAPI\n\n- LangChain: LangChain enables building large language model (LLM) applications that can dynamically interact with databases and external systems. It helps set up a chatbot that can fetch data from knowledge bases like databases, APIs, and even web pages.\n  - Steps:\n    1. Store Knowledge: Define a knowledge base, which could be a SQL database, document store, or API.\n    2. Query Execution: Use an LLM with the LangChain framework to query the knowledge base dynamically.\n    3. FastAPI Integration: Combine this with FastAPI for serving the chatbot with dynamic knowledge retrieval.\n\n### Document Retrieval with Plugins or Middleware\n\n- OpenAI Plugins: If you're using OpenAI in an application, consider building or using a plugin or middleware that acts as a bridge to your knowledge base. For example, retrieving documents, querying databases, or even triggering workflows (e.g., customer support tickets) based on the query.\n- Use case: Ideal for more complex enterprise solutions, where OpenAI can function alongside existing systems.\n\n### Hybrid QA Pipelines (LLM + Traditional Search)\n\n- **Combining LLMs with traditional search**: You can combine the capabilities of language models with traditional search mechanisms like Elasticsearch or other keyword-based systems.\n  - **Method**: First, use search engines to retrieve relevant documents, and then pass those documents to OpenAI for processing and summarization.\n  - **Use case**: Works well in applications where quick retrieval from a large corpus of documents is needed, and then those documents are summarized or clarified by the LLM.","readingTime":"7 min read"}},"__N_SSG":true}